<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>AR Šipka na zemi</title>
<style>
body { margin:0; overflow:hidden; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/webxr/ARButton.js';

let container;
let camera, scene, renderer;
let reticle;
let hitTestSource = null;
let hitTestSourceRequested = false;
let arrowMesh;
let placed = false;
const visibilityThreshold = 30; // Tolerance v stupních

function init() {
container = document.createElement('div');
document.body.appendChild(container);

scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
light.position.set(0.5, 1, 0.25);
scene.add(light);

reticle = new THREE.Mesh(
new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
new THREE.MeshBasicMaterial()
);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

const controller = renderer.xr.getController(0);
controller.addEventListener('select', onSelect);
scene.add(controller);

window.addEventListener('resize', onWindowResize);
}

function createArrow() {
const group = new THREE.Group();
const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });

const shaft = new THREE.Mesh(
new THREE.CylinderGeometry(0.05, 0.05, 1, 32),
material
);
shaft.position.y = 0.5;
group.add(shaft);

const head = new THREE.Mesh(
new THREE.ConeGeometry(0.1, 0.3, 32),
material
);
head.position.y = 1;
group.add(head);

return group;
}

function onSelect() {
if (placed) return;
if (reticle.visible) {
arrowMesh = createArrow();
arrowMesh.matrix.fromArray(reticle.matrix.elements);
scene.add(arrowMesh);
placed = true;
reticle.visible = false;
}
}

function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function handleVisibility(frame) {
if (!arrowMesh) return;
const referenceSpace = renderer.xr.getReferenceSpace();
const pose = frame.getViewerPose(referenceSpace);
if (pose) {
const camPos = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
const arrowPos = new THREE.Vector3().setFromMatrixPosition(arrowMesh.matrixWorld);
const dirToArrow = arrowPos.clone().sub(camPos).normalize();
const camForward = new THREE.Vector3();
camera.getWorldDirection(camForward);
const dot = dirToArrow.dot(camForward);
const angle = Math.acos(dot) * 180 / Math.PI;
arrowMesh.visible = (angle <= visibilityThreshold);
}
}

function render(timestamp, frame) {
if (frame) {
const referenceSpace = renderer.xr.getReferenceSpace();
const session = renderer.xr.getSession();

if (hitTestSourceRequested === false) {
session.requestReferenceSpace('viewer').then((referenceSpace) => {
session.requestHitTestSource({ space: referenceSpace }).then((source) => {
hitTestSource = source;
});
});
session.addEventListener('end', () => {
hitTestSourceRequested = false;
hitTestSource = null;
});
hitTestSourceRequested = true;
}

if (hitTestSource) {
const hitTestResults = frame.getHitTestResults(hitTestSource);
if (hitTestResults.length) {
const hit = hitTestResults[0];
reticle.visible = !placed;
reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
} else {
reticle.visible = false;
}
}

handleVisibility(frame);
}

renderer.render(scene, camera);
}

init();
renderer.setAnimationLoop(render);
</script>
</body>
</html>
